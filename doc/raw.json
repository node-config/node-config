{"majorversion": 3, "classmap": {"ConfigTest": {"name": "ConfigTest", "namespace": "", "module": "test", "guessedname": "ConfigTest", "file": "2-config-test.js", "guessedtype": "property", "shortname": "ConfigTest", "description": "<p>Unit tests for the node-config library.  To run type:</p>\n<pre>npm test</pre>\n<p>Or, in a project that uses node-config:</p>\n<pre>npm test config</pre>"}, "Config": {"name": "Config", "namespace": "", "module": "config", "methods": {"_initParam": {"return": {"type": "Any", "description": "The found value, or default value"}, "params": [{"type": "String", "name": "paramName", "description": "  Name of the parameter"}, {"type": "Any", "name": "[defaultValue]", "description": "  Default value of the parameter"}], "description": "<p>Initialize a parameter from the command line or process environment</p>\n<p>\nThis method looks for the parameter from the command line in the format\n--PARAMETER=VALUE, then from the process environment, then from the\ndefault specified as an argument.\n</p>", "guessedname": "_initParam", "guessedtype": "function"}, "_diffDeep": {"return": {"type": "object", "description": "A differential object, which if extended onto object1 would\nresult in object2."}, "description": "Returns an object containing all elements that differ between two objects.\n<p>\nThis method was designed to be used to create the runtime.json file\ncontents, but can be used to get the diffs between any two Javascript objects.\n</p>\n<p>\nIt works best when object2 originated by deep copying object1, then\nchanges were made to object2, and you want an object that would give you\nthe changes made to object1 which resulted in object2.\n</p>", "protected": "", "params": [{"type": "object", "name": "object1", "description": "  The base object to compare to"}, {"type": "object", "name": "object2", "description": "  The object to compare with"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_diffDeep", "guessedtype": "function"}, "_loadFileConfigs": {"protected": "", "return": {"type": "this", "description": "The configuration object"}, "description": "Load the individual file configurations.\n<p>\nThis method builds a map of filename to the configuration object defined\nby the file.  The search order is:\n</p>\n<pre>\ndefault.EXT\n(hostname).EXT\n(deployment).EXT\n(hostname)-(deployment).EXT\nlocal.EXT\nlocal-(deployment).EXT\nruntime.json\n</pre>\n<p>\nEXT can be yml, yaml, coffee, json, or js signifying the file type.\nyaml (and yml) is in YAML format, coffee is a coffee-script,\njson is in JSON format, and js is a javascript executable file that is\nrequire()'d with module.exports being the config object.\n</p>\n<p>\nhostname is the $HOST environment variable (or --HOST command line parameter)\nif set, otherwise the $HOSTNAME environment variable (or --HOSTNAME command\nline parameter) if set, otherwise the hostname found from\nrequire('os').hostname().\n</p>\n<p>\nOnce a hostname is found, everything from the first period ('.') onwards\nis removed. For example, abc.example.com becomes abc\n</p>\n<p>\n(deployment) is the deployment type, found in the $NODE_ENV environment\nvariable or --NODE_ENV command line parameter.  Defaults to 'development'.\n</p>\n<p>\nThe runtime.json file contains configuration changes made at runtime either\nmanually, or by the application setting a configuration value.\n</p>\n<p>\nIf the $NODE_APP_INSTANCE environment variable (or --NODE_APP_INSTANCE\ncommand line parameter) is set, then files with this appendage will be loaded.\nSee the Multiple Applicstion Instances section of the main documentaion page\nfor more information.\n</p>", "guessedname": "_loadFileConfigs", "guessedtype": "function"}, "watchForConfigFileChanges": {"params": [{"type": "Integer", "name": "interval", "description": "  - Polling interval in milliseconds.  Defaults to 2500."}], "description": "Start or stop runtime.json configuration file watching\n<p>\nNode-config automatically monitors and apply changes made to the\nconfig/runtime.json file.  This paradigm allows for manual changes to running\napplication servers, and for multi-node application servers to keep in sync.\n</p>\n<p>\nThis method allows you to change the polling interval from the default\ninterval (2.5 seconds), or to turn file watching off.  On Linux systems with\ninotify, and in node.js versions 0.6 and above, this interval is ignored.\n</p>\n<p>\nruntime.json file watching can be disabled by setting the NODE_CONFIG_DISABLE_FILE_WATCH\nenvironment variable or --NODE_CONFIG_DISABLE_FILE_WATCH command line parameter\nto \"Y\" prior to running your application.\n</p>", "guessedname": "watchForConfigFileChanges", "guessedtype": "function"}, "setModuleDefaults": {"return": {"type": "object", "description": "moduleConfig  - The module level configuration object."}, "params": [{"type": "string", "name": "moduleName", "description": "  - Name of your module."}, {"type": "object", "name": "defaultProperties", "description": "  - The default module configuration."}], "description": "<p>\nSet default configurations for a node.js module.\n</p>\n<p>\nThis allows module developers to attach their configurations onto the\ndefault configuration object so they can be configured by the consumers\nof the module.\n</p>\n<p>Using the function within your module:</p>\n<pre>\nvar CONFIG = require(\"config\");\nCONFIG.setModuleDefaults(\"MyModule\", {\n&nbsp;&nbsp;templateName: \"t-50\",\n&nbsp;&nbsp;colorScheme: \"green\"\n});\n<br>\n// Template name may be overridden by application config files\nconsole.log(\"Template: \" + CONFIG.MyModule.templateName);\n</pre>\n<p>\nThe above example results in a \"MyModule\" element of the configuration\nobject, containing an object with the specified default values.\n</p>", "guessedname": "setModuleDefaults", "guessedtype": "function"}, "_isObject": {"return": {"type": "boolean", "description": "TRUE if the arg is an object, FALSE if not"}, "description": "Is the specified argument a regular javascript object?\nThe argument is an object if it's a JS object, but not an array.", "protected": "", "params": [{"type": "MIXED", "name": "arg", "description": "  An argument of any type."}], "guessedname": "_isObject", "guessedtype": "function"}, "_getCmdLineArg": {"return": {"type": "MIXED", "description": "FALSE if the argument was not found, the argument value if found"}, "params": [{"type": "STRING", "name": "searchFor", "description": "  The argument name to search for"}], "description": "<p>Get Command Line Arguments</p>\n<p>\nThis method allows you to retrieve the value of the specified command line argument.\n</p>\n<p>\nThe argument is case sensitive, and must be of the form '--ARG_NAME=value'\n</p>", "guessedname": "_getCmdLineArg", "guessedtype": "function"}, "_cloneDeep": {"return": {"type": "object", "description": "A new object with the elements copied from the copyFrom object"}, "description": "Return a deep copy of the specified object.\nThis returns a new object with all elements copied from the specified\nobject.  Deep copies are made of objects and arrays so you can do anything\nwith the returned object without affecting the input object.", "protected": "", "params": [{"type": "object", "name": "copyFrom", "description": "  The original object to copy from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_cloneDeep", "guessedtype": "function"}, "_loadOldStyleEnv": {"return": {"type": "Object", "description": "old-style configurations from process.env"}, "description": "Check for the old-style environment variable configurations", "deprecated": "", "protected": "", "guessedname": "_loadOldStyleEnv", "guessedtype": "function"}, "getOriginalConfig": {"return": {"type": "object", "description": "The original config object is returned"}, "description": "<p>Exposing original Config</p>\n<p>\nThis method allows get the original config properties.\n</p>", "guessedname": "getOriginalConfig", "guessedtype": "function"}, "_stripComments": {"return": {"type": "string", "description": "The string with comments stripped."}, "description": "Strip all Javascript type comments from the string.\nThe string is usually a file loaded from the O/S, containing\nnewlines and javascript type comments.\nThanks to James Padolsey, and all who conributed to this implementation.\nhttp://james.padolsey.com/javascript/javascript-comment-removal-revisted/", "protected": "", "params": [{"type": "string", "name": "fileString", "description": "  The string to strip comments from"}], "guessedname": "_stripComments", "guessedtype": "function"}, "makeHidden": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to make a hidden property into."}, {"type": "string", "name": "property", "description": "  - The name of the property to make hidden."}, {"type": "mixed", "name": "value", "description": "  - (optional) Set the property value to this (otherwise leave alone)"}], "description": "<p>Make a configuration property hidden so it doesn't appear when enumerating\nelements of the object.</p>\n<p>\nThe property still exists and can be read from and written to, but it won't\nshow up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n</p>\n<p>\nIf the property already exists, it will be made hidden.  Otherwise it will\nbe created as a hidden property with the specified value.\n</p>\n<p><i>\nThis method was built for hiding configuration values, but it can be applied\nto <u>any</u> javascript object.\n</i></p>\n<p>Example:</p>\n<pre>\nvar CONFIG = require('config');\n...\n// Hide the Amazon S3 credentials\nCONFIG.makeHidden(CONFIG.amazonS3, 'access_id');\nCONFIG.makeHidden(CONFIG.amazonS3, 'secret_key');\n</pre>", "guessedname": "makeHidden", "guessedtype": "function"}, "safeWriteFile": {"params": [{"type": "String", "name": "filename", "description": "  Filename to write to."}, {"type": "String", "name": "content", "description": "   Data to write."}, {"type": "Function", "name": "callback", "description": "  Callback function."}], "description": "<p>Safely write a file</p>\n<p>\nThis method safely overwrites a file by first writing to a temporary file\nand then renaming it. This to ensure no other process reads to file in a\ntruncated state.\n</p>", "guessedname": "safeWriteFile", "guessedtype": "function"}, "watch": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to watch."}, {"type": "string", "name": "property", "description": "  - The property name to watch.  Watch all object properties if null."}, {"type": "function(object, propertyName, priorValue, newValue)", "name": "handler", "description": "  - Handler called when a property change is detected.\nThe handler is run along with other handlers registered for notification.\nIf your handler changes the value of the property, that change is applied after all handlers have finished processing the current change.\nThen all handlers (including this one) will be called again with the newly changed value."}, {"type": "integer", "name": "depth", "description": "  (optional) - If watching all object properties or if the specified property is an object, this specifies the depth of the object graph to watch for changes.  Default 6."}], "description": "<p>Monitor a configuration value for runtime changes.</p>\n<p>\nConfiguration values can be changed at runtime by the application or by a\nmanual change to the config/runtime.json  file.\nThis method lets you specify a function to run when a configuration\nvalue changes.\n</p>\n<p><i>\nThis was built for monitoring changes to configuration values,\nbut it can be used for watching changes to <u>any</u> javascript object.\n</i></p>\n<p>Example:</p>\n<pre>\nvar CONFIG = require('config').customer;\n...\n// Watch for any changes to the customer configuration\nCONFIG.watch(CONFIG, null, function(object, propertyName, priorValue, newValue) {\n&nbsp;console.log(\"Customer configuration \" + propertyName + \" changed from \" + priorValue + \" to \" + newValue);\n});\n</pre>", "guessedname": "watch", "guessedtype": "function"}, "_equalsDeep": {"return": {"type": "boolean", "description": "True if both objects have equivalent contents"}, "description": "Return true if two objects have equal contents.", "protected": "", "params": [{"type": "object", "name": "object1", "description": "  The object to compare from"}, {"type": "object", "name": "object2", "description": "  The object to compare with"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_equalsDeep", "guessedtype": "function"}, "_stripYamlComments": {"return": {"type": "string", "description": "The string with comments stripped."}, "description": "Strip YAML comments from the string\nThe 2.0 yaml parser doesn't allow comment-only or blank lines.  Strip them.", "protected": "", "params": [{"type": "string", "name": "fileString", "description": "  The string to strip comments from"}], "guessedname": "_stripYamlComments", "guessedtype": "function"}, "makeImmutable": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to attach an immutable property into."}, {"type": "string", "name": "property", "description": "  - The name of the property to make immutable."}, {"type": "mixed", "name": "value", "description": "  - (optional) Set the property value to this (otherwise leave alone)"}], "description": "<p>Make a configuration property immutable (assuring it cannot be changed\nfrom the current value).</p>\n<p>\nThis operation cannot be undone.\n</p>\n<p><i>\nThis method was built for disabling runtime changes to configuration values,\nbut it can be applied to <u>any</u> javascript object.\n</i></p>\n<p>Example:</p>\n<pre>\nvar CONFIG = require('config').customer;\n...\n// Obtain a DB connection using CONFIG parameters\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n// Don't allow database changes after connect\nCONFIG.makeImmutable(CONFIG.db, 'name');\nCONFIG.makeImmutable(CONFIG.db, 'port');\n</pre>", "guessedname": "makeImmutable", "guessedtype": "function"}, "_parseFile": {"return": {"type": "configObject", "description": "The configuration object parsed from the file"}, "description": "Parse and return the specified configuration file.\nIf the file exists in the application config directory, it will\nparse and return it as a JavaScript object.\nThe file extension determines the parser to use.\n.js = File to run that has a module.exports containing the config object\n.json = File is parsed using JSON.parse()\n.coffee = File to run that has a module.exports with coffee-script containing the config object\n.yaml (or .yml) = Parsed with a YAML parser\nIf the file doesn't exist, a null will be returned.  If the file can't be\nparsed, an exception will be thrown.\nThis method performs synchronous file operations, and should not be called\nafter synchronous module loading.", "protected": "", "params": [{"type": "string", "name": "fullFilename", "description": "  The full file path and name"}], "guessedname": "_parseFile", "guessedtype": "function"}, "_attachProtoDeep": {"return": {"type": "", "description": "toObject"}, "description": "Attach the Config class prototype to all config objects recursively.\n<p>\nThis allows you to do anything with CONFIG sub-objects as you can do with\nthe top-level CONFIG object.  It's so you can do this:\n</p>\n<pre>\nvar CUST_CONFIG = require('config').Customer;\nCUST_CONFIG.watch(...)\n</pre>", "protected": "", "params": [{"type": "", "name": "toObject", "description": ""}, {"type": "", "name": "depth", "description": ""}], "guessedname": "_attachProtoDeep", "guessedtype": "function"}, "getConfigSources": {"return": {"type": "Array[Object]", "description": "configSources  - An array of objects containing\nname, original, and parsed elements"}, "description": "Return the sources for the configurations\n<p>\nAll sources for configurations are stored in an array of objects containing\nthe source name (usually the filename), the original source (as a string),\nand the parsed source as an object.\n</p>", "guessedname": "getConfigSources", "guessedtype": "function"}, "_persistConfigsOnChange": {"protected": "", "params": [{"type": "object", "name": "object", "description": "  - The config object to watch"}], "description": "<p>\nWatch the specified object for a change in properties, and persist changes\nto runtime.json when a change is detected.\n</p>", "guessedname": "_persistConfigsOnChange", "guessedtype": "function"}, "constructor": {"return": {"type": "object", "description": "CONFIG  - The top level configuration object"}, "description": "<p>Get the configuration object.</p>\n<p>\nThe configuration object is a shared singleton object within the application,\nattained by calling require('config').\n</p>\n<p>\nUsually you'll specify a CONFIG variable at the top of your .js file\nfor file/module scope. If you want the root of the object, you can do this:\n</p>\n<pre>\nvar CONFIG = require('config');\n</pre>\n<p>\nSometimes you only care about a specific sub-object within the CONFIG\nobject.  In that case you could do this at the top of your file:\n</p>\n<pre>\nvar CONFIG = require('config').customer;\nor\nvar CUSTOMER_CONFIG = require('config').customer;\n</pre>\n<script type=\"text/javascript\">\ndocument.getElementById(\"showProtected\").style.display = \"block\";\n</script>", "guessedname": "Config", "guessedtype": "function"}, "_extendDeep": {"return": {"type": "object", "description": "The altered mergeInto object is returned"}, "description": "Extend an object, and any object it contains.\nThis does not replace deep objects, but dives into them\nreplacing individual elements instead.", "protected": "", "params": [{"type": "object", "name": "mergeInto", "description": "  The object to merge into"}, {"type": "object...", "name": "mergeFrom...", "description": "  - Any number of objects to merge from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_extendDeep", "guessedtype": "function"}, "resetRuntime": {"params": [{"type": "function", "name": "callback", "description": "  An optional callback function"}], "description": "<p>Reset Runtime Config</p>\n<p>\nThis method allows you to reset the runtime.json generated file.\n</p>", "guessedname": "resetRuntime", "guessedtype": "function"}}, "file": "config.js", "shortname": "Config", "description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module exports a singleton object representing all runtime\nconfigurations for this application deployment.\n</p>\n<p>\nApplication configurations are stored in files within the config directory\nof your application.  The default configuration file is loaded, followed\nby files specific to the deployment type (development, testing, staging,\nproduction, etc.).\n</p>\n<p>\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThe following code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>"}, "ProtectedTest": {"name": "ProtectedTest", "namespace": "", "module": "test", "guessedname": "PrivateTest", "file": "1-protected-test.js", "guessedtype": "property", "shortname": "ProtectedTest", "description": "<p>Tests for underlying node-config utilities.  To run type:</p>\n<pre>npm test</pre>\n<p>Or, in a project that uses node-config:</p>\n<pre>npm test config</pre>"}}, "version": "0.4.35", "modules": {"test": {"description": "<p>Unit tests</p>", "submodules": [], "classlist": ["ProtectedTest", "ConfigTest"], "filelist": ["1-protected-test.js", "2-config-test.js", "default.js"], "subdata": {}, "name": "test"}, "config": {"description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module exports a singleton object representing all runtime\nconfigurations for this application deployment.\n</p>\n<p>\nApplication configurations are stored in files within the config directory\nof your application.  The default configuration file is loaded, followed\nby files specific to the deployment type (development, testing, staging,\nproduction, etc.).\n</p>\n<p>\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThe following code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>", "submodules": [], "classlist": ["Config"], "filelist": ["config.js"], "subdata": {}, "name": "config"}}, "filemap": {"default.js": {"classlist": [], "name": "default.js", "module": "test"}, "2-config-test.js": {"classlist": ["ConfigTest"], "name": "2-config-test.js", "module": "test"}, "config.js": {"classlist": ["Config"], "name": "config.js", "module": "config"}, "1-protected-test.js": {"classlist": ["ProtectedTest"], "name": "1-protected-test.js", "module": "test"}}}