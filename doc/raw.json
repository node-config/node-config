{"majorversion": 3, "classmap": {"ConfigTest": {"name": "ConfigTest", "constructors": [{"description": "<p>Unit tests for the node-config library.  To run type:</p>\n<pre>npm test</pre>"}], "namespace": "", "module": "test", "guessedname": "ConfigTest", "file": "2-config-test.js", "guessedtype": "property", "shortname": "ConfigTest", "description": "<p>Unit tests for the node-config library.  To run type:</p>\n<pre>npm test</pre>"}, "Config": {"file": "config.js", "description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module is a singleton class representing all runtime\nconfigurations for this application instance.\n</p>\n<p>\nThe require('config') constructor returns the global configuration object.\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThis code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>", "namespace": "", "module": "node-config", "methods": {"_attachProtoDeep": {"return": {"type": "", "description": "toObject"}, "description": "Attach the Config class prototype to all config objects recursively.\n<p>\nThis allows you to do anything with CONFIG sub-objects as you can do with\nthe top-level CONFIG object.  It's so you can do this:\n</p>\n<pre>\nvar CONFIG = require('config').Customer;\nCONFIG.watch(...)\n</pre>", "protected": "", "params": [{"type": "", "name": "toObject", "description": ""}, {"type": "", "name": "depth", "description": ""}], "guessedname": "_attachProtoDeep", "guessedtype": "function"}, "_watchForConfigFileChanges": {"protected": "", "description": "Monitor the filesystem for configuration file changes.\n<p>\nRuntime configuration changes are made by modifying the runtime.json file.\nThis paradigm allows multiple application servers to internally notify\nlisteners whenever the configuration changes.\n</p>\n<p>\nThis method attaches the file watcher onto the runtime.json file.\n</p>", "guessedname": "_watchForConfigFileChanges", "guessedtype": "function"}, "watch": {"return": {"type": "object", "description": "object  - The original object is returned."}, "params": [{"type": "object", "name": "object", "description": "  - The object to watch.  Can be any javascript object."}, {"type": "string", "name": "property", "description": "  - The property name to watch.  Watch all object properties if null."}, {"type": "function(object, propertyName, priorValue, newValue)", "name": "handler", "description": "  - Handler called when a property change is detected.\nThe handler is run along with other handlers registered for notification.\nIf the handler changes the value of the property, that change is applied after all handlers have finished processing the current change.\nThen all handlers (including this one) will be called again with the newly changed value."}, {"type": "integer", "name": "depth", "description": "  (optional) - If watching all object properties or if the specified property is an object, this specifies the depth of the object graph to watch for changes.  Default 6."}], "description": "<p>Monitor a configuration value for runtime changes.</p>\n<p>\nConfiguration values can be changed in a running application by the \napplication applying changes, or by a manual change to the runtime.json\nfile within the configuration directory. This method lets you specify a \nfunction to run if a configuration value changes.  \n</p>\n<p>\nIf you want to prevent changes to configuration values, it's better to use \nthe makePropertyImmutable method.\n</p>\n<p>\nThis method was built for monitoring changes to configuration values,\nbut it can be used for watching changes to any javascript object.\n</p>", "guessedname": "watch", "guessedtype": "function"}, "makeImmutable": {"params": [{"type": "object", "name": "object", "description": "  - The object to attach an immutable property into."}, {"type": "string", "name": "property", "description": "  - The name of the property to make immutable."}], "description": "<p>Make a configuration property immutable (assuring it cannot be changed).</p>\n<p>\nThis method was built for configuration properties that shouldn't change,\nbut it can be applied to any javascript object property.\n</p>\n<p>\nThis operation cannot be un-done.\n</p>", "guessedname": "makeImmutable", "guessedtype": "function"}, "_cloneDeep": {"return": {"type": "object", "description": "A new object with the elements copied from the copyFrom object"}, "description": "Return a deep copy of the specified object.\nThis returns a new object with all elements copied from the specified\nobject.  Deep copies are made of objects and arrays so you can do anything\nwith the returned object without affecting the input object.", "protected": "", "params": [{"type": "object", "name": "copyFrom", "description": "  The original object to copy from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_cloneDeep", "guessedtype": "function"}, "_loadFileConfigs": {"return": {"type": "this", "description": "The configuration object"}, "description": "Load the individual file configurations.\n<p>\nThis method builds a map of filename to the configuration object defined\nby the file.  The search order is:\n</p>\n<pre>\ndefault.EXT\n(hostname).EXT\n(deployment).EXT\n(hostname)-(deployment).EXT\nruntime.json\n</pre>\n<p>\nEXT can be yaml, json, or js signifying the file type.  yaml is in YAML format,\njson is in strict JSON format, and js is a javascript executable file that is\nrequire()'d with module.exports being the config object.\n</p>\n<p>\n(hostname) is the $HOST environment variable if set, otherwise the\n$HOSTNAME environment variable if set, otherwise the hostname found from\nrequire('os').hostname()\n</p>\n<p>\n(deployment) is the deployment type, found in the $NODE_ENV environment\nvariable.  Defaults to 'development'.\n</p>\n<p>\nThe runtime.json file contains configuration changes made at runtime via\nthe CONFIG.set('element',value) method.\n</p>", "param": "fullFilename {string} The full file path and name", "protected": "", "guessedname": "_loadFileConfigs", "guessedtype": "function"}, "_extendDeep": {"return": {"type": "object", "description": "The altered mergeInto object is returned"}, "description": "Extend an object, and any object it contains.\nThis does not replace deep objects, but dives into them\nreplacing individual elements instead.", "protected": "", "params": [{"type": "object", "name": "mergeInto", "description": "  The object to merge into"}, {"type": "object...", "name": "mergeFrom...", "description": "  - Any number of objects to merge from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_extendDeep", "guessedtype": "function"}, "_isObject": {"return": {"type": "boolean", "description": "TRUE if the arg is an object, FALSE if not"}, "description": "Is the specified argument an object?\nThe argument is an object if it's a JS object, but not an array.", "protected": "", "params": [{"type": "MIXED", "name": "arg", "description": "  An argument of any type."}], "guessedname": "_isObject", "guessedtype": "function"}, "_buildConfig": {"protected": "", "description": "<p>Assemble the configuration object members into this object</p>", "guessedname": "_buildConfig", "guessedtype": "function"}}, "guessedname": "Config", "guessedtype": "function", "shortname": "Config", "name": "Config"}, "ProtectedTest": {"name": "ProtectedTest", "constructors": [{"description": "<p>Tests for protected (hackable) utilities.</p>"}], "namespace": "", "module": "test", "guessedname": "PrivateTest", "file": "1-protected-test.js", "guessedtype": "property", "shortname": "ProtectedTest", "description": "<p>Tests for protected (hackable) utilities.</p>"}}, "version": "0.4.0", "modules": {"node-config": {"description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module is a singleton class representing all runtime\nconfigurations for this application instance.\n</p>\n<p>\nThe require('config') constructor returns the global configuration object.\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThis code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>", "submodules": [], "classlist": ["Config"], "filelist": ["config.js"], "subdata": {}, "name": "node-config"}, "test": {"description": "<p>Unit tests</p>", "submodules": [], "classlist": ["ProtectedTest", "ConfigTest"], "filelist": ["1-protected-test.js", "2-config-test.js"], "subdata": {}, "name": "test"}}, "filemap": {"2-config-test.js": {"classlist": ["ConfigTest"], "name": "2-config-test.js", "module": "test"}, "config.js": {"classlist": ["Config"], "name": "config.js", "module": "node-config"}, "1-protected-test.js": {"classlist": ["ProtectedTest"], "name": "1-protected-test.js", "module": "test"}}}